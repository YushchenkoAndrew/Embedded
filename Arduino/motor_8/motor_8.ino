#include"timer-api.h"
volatile bool q=false;
volatile int i=10;
volatile int last;
int j;
byte times=1;
bool w=false,z=1;
byte mirrow[10]={
                0,
                3,
                2,
                1,
                0,
                7,
                6,
                5,
                4
               };
byte pause[10]={
                0,
                143,
                95,
                0,
                37,
                60,
                65, 
                80, 
                90
               };
byte mass[90]={0x00, 0x00, 0x00, 0x18, 0x3C, 0x24, 0x66,
  0x42, 0xC3, 0x81, 0x81, 0xFF, 0xFF, 0xFF, 0x81, 0x81, 0xC3, 0x42, 0x66,
  0x24, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03,
  0x03, 0x03, 0x03, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xC0, 0x60, 0x30, 0x18,
  0x0C, 0x06, 0x03, 0x03, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
byte mass2[90]={0x00, 0x00, 0x00, 0x82, 0xC3, 0xE1, 0xB1, 0x99, 0x8D, 0xC7, 0x42, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0xC1, 0xE1, 0xB1, 0x99, 0x8D,
  0x87, 0x83, 0x7E, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
  0x86, 0x83, 0x81, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x6E,
  0x6E, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x6E, 0x6E, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
void setup()
{
  pinMode(2,INPUT);
  pinMode(7,OUTPUT);
  last=100;
  attachInterrupt(0, zero, FALLING);
  timer_init_ISR_1Hz(TIMER_DEFAULT);
  while (q != 0);
}
void zero()
{
  q=1;
}

void timer_handle_interrupts(int timer) {
  times++;
  if (times % 5 == 0){
z=!z;
times=1;
  }
}

bool pixel()
{
  if (z)
 switch (mirrow[i])
 {
  case 0: return bool(mass[j] & 1); break;
  case 1: return bool(mass[j] & 2); break;
  case 2: return bool(mass[j] & 4); break;
  case 3: return bool(mass[j] & 8); break;
  case 4: return bool(mass[j] & 16); break;
  case 5: return bool(mass[j] & 32); break;
  case 6: return bool(mass[j] & 64); break;
  case 7: return bool(mass[j] & 128); break;
 }
 else
  switch (mirrow[i])
 {
  case 0: return bool(mass2[j] & 1); break;
  case 1: return bool(mass2[j] & 2); break;
  case 2: return bool(mass2[j] & 4); break;
  case 3: return bool(mass2[j] & 8); break;
  case 4: return bool(mass2[j] & 16); break;
  case 5: return bool(mass2[j] & 32); break;
  case 6: return bool(mass2[j] & 64); break;
  case 7: return bool(mass2[j] & 128); break;
 }
}
void readholes()
{ if (q){ i=0; q=0;} else {
  if ((!(PIND & 0b00001000))&&(w))
  {
  i++;
  w=false;
  }
  if (PIND & 0b00001000)
  w=true; 
}
 
}

void loop()
{
  readholes();
  if (last != i)
  {
 
  for (j=0; j<=pause[i]; j++) 
    digitalWrite(7,0);
    for (j=0; j<=84; j++) 
    {
    if (pixel())  PORTD |= (1<<7); else  PORTD &=~ (1<<7);
    delayMicroseconds(18);
    }
    PORTD &= ~(1<<7);
    last=i;
  }
}

